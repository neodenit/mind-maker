@page "/"
@using Microsoft.AspNetCore.Components.WebAssembly.Authentication

@using Neodenit.MindMaker.Web.Shared

@inject HttpClient HttpClient

<div class="container-fluid">
    <h1>Mind Maps</h1>

    <div class="row">
        @for (int i = 0; i < nodeLayers.Count; i++)
        {
            var layer = nodeLayers[i];
            var index = i;

            <div class="col-sm">
                @if (HasNodes(i))
                {
                    <div class="form-group">

                        @foreach (var node in layer)
                        {
                            <button @onclick="() => NodeClickAsync(node, index)" class="@GetNodeStyle(i, node)">@(node.Name)</button>
                        }

                    </div>
                }

                @if (i == 0 && !IsLoaded())
                {
                    <div class="alert alert-warning" role="alert">
                        Loading mind maps...
                    </div>
                }

                @if (IsLoaded() && !isAdding[i] && (HasNodes(i) || i == 0))
                {
                    if (!(i == 0 && IsOpened(i)))
                    {
                        <button class="btn btn-outline-primary btn-block" type="submit" @onclick="() => StartAddingAsync(index)">+</button>
                    }

                    if (IsOpened(i))
                    {
                        <button class="btn btn-outline-danger btn-block" type="button" @onclick="() => DeleteAsync(index)">Delete</button>
                    }
                }

                @if (isAdding[i])
                {
                    <form @onsubmit="() => AddAsync(newNodeName, index)">
                        @if (advice is not null)
                        {
                            if (advice.Any())
                            {
                                <div class="form-group">
                                    @foreach (var item in advice)
                                    {
                                        if (!string.IsNullOrEmpty(item))
                                        {
                                            <button class="btn btn-success btn-block" type="button" @onclick="() => AddAsync(item, index)">@item</button>
                                        }
                                    }
                                </div>
                            }
                        }
                        else
                        {
                            <div class="alert alert-warning" role="alert">
                                Loading advice...
                            </div>
                        }

                        <div class="form-group">
                            <input @bind="newNodeName" type="text" class="form-control" required autofocus>
                        </div>

                        <div class="form-group">
                            <button class="btn btn-outline-primary btn-block" type="submit">Add</button>
                            <button class="btn btn-outline-secondary btn-block" type="button" @onclick="() => Cancel(index)">Cancel</button>
                        </div>
                    </form>
                }

            </div>
        }
    </div>
</div>

@code
{
    private string newNodeName;
    private IEnumerable<string> advice;

    private IEnumerable<NodeModel> mindMaps = Enumerable.Empty<NodeModel>();

    private IList<IEnumerable<NodeModel>> nodeLayers = new IEnumerable<NodeModel>[Constants.MaxDepth];
    private IList<bool> isAdding = new bool[Constants.MaxDepth];

    protected override async Task OnInitializedAsync()
    {
        try
        {
            mindMaps = await HttpClient.GetFromJsonAsync<IEnumerable<NodeModel>>($"api/MindMap");

            nodeLayers[0] = mindMaps;
        }
        catch (AccessTokenNotAvailableException exception)
        {
            exception.Redirect();
        }
    }

    private async Task AddAsync(string itemName, int level)
    {
        var path = GetPath(level);
        var ids = path.Select(x => x.Id);

        var request = new CreateItemRequestModel { NewItemName = itemName, Path = ids };

        var newNodeMessage = await HttpClient.PostAsJsonAsync("api/MindMap", request);
        var newNode = await newNodeMessage.Content.ReadFromJsonAsync<NodeModel>();

        if (nodeLayers[level] is null)
        {
            nodeLayers[level] = Enumerable.Repeat(newNode, 1);
        }
        else
        {
            nodeLayers[level] = nodeLayers[level].Append(newNode);
        }

        if (level > 0)
        {
            var parentNode = nodeLayers[level - 1].Single(x => x.IsOpened);
            parentNode.Children = nodeLayers[level];
        }

        newNodeName = string.Empty;

        StopAdding();
    }

    private void Cancel(int level)
    {
        isAdding[level] = false;
        newNodeName = string.Empty;

        if (level > 0 && !nodeLayers[level].Any())
        {
            CloseNodes(level - 1);
        }
    }

    private async Task NodeClickAsync(NodeModel node, int level)
    {
        StopAdding();

        if (node.Children.Any())
        {
            if (node.IsOpened)
            {
                HideLayers(level + 1);

                node.IsOpened = false;
            }
            else
            {
                nodeLayers[level + 1] = node.Children;

                HideLayers(level + 2);
                CloseNodes(level);

                node.IsOpened = true;
            }
        }
        else
        {
            CloseNodes(level);
            node.IsOpened = true;

            var nextLevel = level + 1;

            if (nextLevel < Constants.MaxDepth)
            {
                HideLayers(nextLevel);

                await StartAddingAsync(nextLevel);
            }
        }
    }

    private void HideLayers(int startingLevel)
    {
        for (int i = startingLevel; i < Constants.MaxDepth; i++)
        {
            nodeLayers[i] = Enumerable.Empty<NodeModel>();
            isAdding[i] = false;
        }
    }

    private void CloseNodes(int level)
    {
        foreach (var item in nodeLayers[level])
        {
            item.IsOpened = false;
        }
    }

    private bool IsOpened(int level)
    {
        var result = nodeLayers[level]?.Any(x => x.IsOpened) == true;
        return result;
    }

    private string GetNodeStyle(int level, NodeModel node)
    {
        if (!IsOpened(level))
        {
            return "btn btn-block btn-warning";
        }
        else
        {
            if (node.IsOpened)
            {
                return "btn btn-block btn-warning";
            }
            else
            {
                if (level == 0)
                {
                    return "d-none";
                }
                else
                {
                    return "btn btn-block btn-light";
                }
            }
        }
    }

    private void StopAdding()
    {
        for (int i = 0; i < isAdding.Count; i++)
        {
            isAdding[i] = false;
        }
    }

    private bool HasNodes(int level)
    {
        var result = nodeLayers[level]?.Any() == true;
        return result;
    }

    private bool IsLoaded()
    {
        var result = nodeLayers[0] is not null;
        return result;
    }

    private async Task StartAddingAsync(int level)
    {
        StopAdding();

        advice = null;

        isAdding[level] = true;

        var path = GetPath(level);
        var request = new AdviceRequestModel { Parents = path.Select(x => x.Name), Root = path.FirstOrDefault() };
        var adviceMessage = await HttpClient.PostAsJsonAsync($"api/GetAdvice", request);
        var adviceOptions = await adviceMessage.Content.ReadFromJsonAsync<IEnumerable<string>>();

        if (HasNodes(level))
        {
            var layer = nodeLayers[level];

            advice = adviceOptions.Where(ac => !layer.Any(node => node.Name == ac));
        }
        else
        {
            advice = adviceOptions;
        }
    }

    private IEnumerable<NodeModel> GetPath(int level)
    {
        var openPath = nodeLayers.Select(layer => layer.SingleOrDefault(node => node.IsOpened));
        var pathToItem = openPath.Take(level);
        return pathToItem;
    }

    private async Task DeleteAsync(int level)
    {
        StopAdding();

        var nodePath = GetPath(level + 1);
        var path = nodePath.Select(x => x.Id);
        var nodeId = path.Last();

        var request = new DeleteItemRequestModel { Path = path };
        var newNodeMessage = await HttpClient.PostAsJsonAsync("api/MindMap/Delete", request);

        HideLayers(level + 1);
        nodeLayers[level] = nodeLayers[level].Where(x => x.Id != nodeId);

        if (level > 0)
        {
            var parent = nodeLayers[level - 1].Single(x => x.IsOpened);
            parent.Children = parent.Children.Where(x => x.Id != nodeId);

            if (!nodeLayers[level].Any())
            {
                CloseNodes(level - 1);
            }
        }
    }
}
